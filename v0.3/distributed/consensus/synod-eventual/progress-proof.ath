#****************************************************************************
# Lines beginning with '#+-' are used to create the hierarchy graph
#+- Proof of eventual progress in Synod
 
# Proof of progress

# NOTES: 
#      1. Lemma2 and Lemma4 correspond to "Lemma 1" and "Lemma 2" in NFM21 paper 
#      2. Progress-Theorem corresponds to "Theorem 1" in NFM21 paper
#****************************************************************************
load "lib/main/nat-less"
load "symbols.ath"
load "system.ath"
load "behavior.ath"
load "conditions.ath"
load "methods.ath"



extend-module Synod{ 

	#-- model specific axioms
	assert model-fair-axioms
	assert model-step-axioms
	assert msg-persists-until-read # can be proven, but asserting for now
	#-- Synod behavior specific axioms
	assert synod-quorum-axioms
	assert Snd-Ruls
	assert Rcv-Rul
	assert synod-state-axioms
	# predicate definition axioms	
	assert synod-has-promises-def-axiom	
	assert synod-has-votes-def-axiom
	assert synod-learn-def-axiom		
	assert nonfaulty-def-axioms
	assert P1-P2-Def
	# extra symbol definitions
	assert symbol-defs







#---------------------------------------------------------------------------- 
####################  NO ASSERTIONS BEYOND THIS POINT  ######################
#----------------------------------------------------------------------------



#----------------------------------------------------------------------------
#-- INTERMEDIATE LEMMAS & THEOREMS FOR PROVING EVENTUAL PROGRESS
#----------------------------------------------------------------------------

#----------------------------------------------------------------------------
# Splitting the behavior of nonfaulty actors into simpler forms

	#-- A nonfaulty acceptor is available if there is a message for it in the multiset
	define acceptor-nonfaulty1 :=
	(forall a .
		( (   (acc a) 
			& (nonfaulty a) 
		  )
				==>
					(forall p T b i v typ .

	  		  	       (inMSet (consM p a typ b v) (mu (config (rho T i))))
	        	  		  ==> (
	        	  		  		  (available (config (rho T i)) a)

	    		    	  		| (exists j .
                                             (i N.< j)
	    		    	  				   & (available (config (rho T j)) a))
	    		    	  	  )		
					)
		) 
	)

	(!prove acceptor-nonfaulty1 [nonfaulty-def-axioms Acc-NF-Axm])

	#-- An nonfaulty acceptor is available if its local state satisfies conditions for it to send a 
	#-- 1b or 2b message 
	define acceptor-nonfaulty2 :=
	(forall a .
		( (   (acc a) 
			& (nonfaulty a) 
		  )
				==>
					(forall p T b i v typ .
					  	(  
							   (  (inMSet (consM p a 1a b v) (amu (als (config (rho T i)) a))) 
							   	& ((beta (als (config (rho T i)) a)) < b)
							   )    	
							|  (  (inMSet (consM p a 2a b v) (amu (als (config (rho T i)) a))) 
							   	& ((beta (als (config (rho T i)) a)) =< b)
							   )    	
                        )
	        	  		  ==> (
	        	  		  		  (available (config (rho T i)) a)

	    		    	  		| (exists j .
                                             (i N.< j)
	    		    	  				   & (available (config (rho T j)) a))
	    		    	  	  )			    
					)
		) 
	)

	(!prove acceptor-nonfaulty2 [nonfaulty-def-axioms Acc-NF-Axm])

	#-- A nonfaulty proposer is available if there is a message for it in the multiset
	define proposer-nonfaulty1 :=
	(forall p .
		( (   (prp p) 
			& (nonfaulty p) 
		  )
				==>
					(forall T i a typ b v .   
        	   		  	  (inMSet (consM a p typ b v) (mu (config (rho T i))) )
		
	        	  		  ==> (
	        	  		  		  (available (config (rho T i)) p)

	    		    	  		| (exists j .
                                             (i N.< j)
	    		    	  				   & (available (config (rho T j)) p))
	    		    	  	  )			    
					)
		) 
	)

	(!prove proposer-nonfaulty1 [nonfaulty-def-axioms Prp-NF-Axm])

	#-- A nonfaulty proposer is available if its local state satisfies conditions for it to send a 
	#-- 2a message 
	define proposer-nonfaulty2 :=
	(forall p .
		( (   (prp p) 
			& (nonfaulty p) 
		  )	
				==>
					(forall T i typ b v Q .
						(
							(has-promises (als (config (rho T i)) p) b  Q)
		        	  		  ==> (
		        	  		  		  (available (config (rho T i)) p)

		    		    	  		| (exists j .
	                                             (i N.< j)
		    		    	  				   & (available (config (rho T j)) p))
		    		    	  	  )			    
	        	  		)  
					)
		) 
	)

	(!prove proposer-nonfaulty2 [nonfaulty-def-axioms Prp-NF-Axm])


#----------------------------------------------------------------------------
#-- Send and receive transitions for a nonfaulty actor are IOE

	define nonfaulty->IOE-rcv :=
		(forall x .
			(nonfaulty x) ==>
			(forall m T i .
		        ((inMSet m (mu (config (rho T i)))) 
		        & (ready-to (rho T i) x (receive x m)))  
	            	==>
	            	(
	            		  (exists j . (i N.<= j) 
	            		   			& (= (rho T (S j)) (then (rho T j) (receive x m))) )                  
	            	    |  (forall k .  (i N.< k)
	            	    				==>
	            	    				(exists j .
		            	    				  (k N.<= j) 
		            	    				& (inMSet m (mu (config (rho T j)))) 
		            	    				& (ready-to (rho T j) x (receive x m))
		            	    			)
	            	    	)			              
	            	) 
    		)
     	)	

	(!prove nonfaulty->IOE-rcv [nonfaulty-def-axioms NF-IOE-Axm])

	define nonfaulty->IOE-snd :=
		(forall x m T i .
				(nonfaulty x) ==>
				(
			        (ready-to (rho T i) x (send x m))  
		            	==>
		            	(
		            		  (exists j . (i N.<= j) 
		            		   			& (= (rho T (S j)) (then (rho T j) (send x m))) )
		            	    |  (forall k .  (i N.< k)
		            	    				==>
		            	    				(exists j .
			            	    				  (k N.<= j) 
			            	    				& (ready-to (rho T j) x (send x m))
			            	    			)
		            	    	) 
		            	) 
	            )	
        )

	(!prove nonfaulty->IOE-snd [nonfaulty-def-axioms NF-IOE-Axm])

#----------------------------------------------------------------------------
	#-- Fair-receive: If at any index in a transition path, a receive transition is enabled
	#-- for an actor that is IOE, then it eventually happens at some index in the same path
	define IOE->Fair-Rcv-Theorem :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((inMSet m (mu (config (rho T i)))) 
				        & (ready-to (rho T i) x (receive x m)))  
			            	==>
				            	(exists j . (i N.<= j) 
		            	    				& (= (rho T (S j)) (then (rho T j) (receive x m))) ) 						
					)

             )	

	define IOErcv-FAIRrcv-rd-absurd :=
		(forall x m T i .
	       (forall k .  (i N.< k)
	    				==>
	    				(exists j .
    	    				  (k N.<= j) 
    	    				& (inMSet m (mu (config (rho T j)))) 
    	    				& (ready-to (rho T j) x (receive x m))
    	    			)
	    	)
    	    	<==>
    	     (~ (exists k . (i N.< k)
    	    			 & (forall j .
    	    			   (k N.<= j)
    	    			     ==>
    	    			     	(~(
            	    			   (inMSet m (mu (config (rho T j)))) 
            	    			 & (ready-to (rho T j) x (receive x m))		            	    			     		
    	    			     	 ))
    	    			   )

    	       ))   		
     	)

	(!prove IOErcv-FAIRrcv-rd-absurd [])

	define IOE-FAIRNESS-LD-same-rcv :=
	(forall x m T i .
		 (= (rho T (S i)) (then (rho T i) (receive x m))) 
		 ==> 
		  (exists j . (i N.<= j) 
		   			& (= (rho T (S j)) (then (rho T j) (receive x m))) )
	)

	conclude IOE-FAIRNESS-LD-same-rcv
    pick-any x:Actor
    pick-any m:Message
    pick-any T:TP 
    pick-any i:N 	
    assume (= (rho T (S i)) (then (rho T i) (receive x m)))
    let{
		ld := (= (rho T (S i)) (then (rho T i) (receive x m)));
		rd := (exists j . (i N.<= j) 
		   	& (= (rho T (S j)) (then (rho T j) (receive x m))) );
		i<=Si := (!uspec N.Less=.reflexive i);
		_ := (!both i<=Si ld)
    }	
    (!egen rd i)

	define nonfaulty->IOE-rcv-transformed :=
		(forall x  m T i .
			(
		        (  (nonfaulty x)
		         & (inMSet m (mu (config (rho T i)))) 
		         & (ready-to (rho T i) x (receive x m)))  
	            	==>
	            	(
						  (exists j . (i N.<= j) 
						   			& (= (rho T (S j)) (then (rho T j) (receive x m))) )                
	            	    |  (forall k .  (i N.< k)
	            	    				==>
	            	    				(exists j .
		            	    				  (k N.<= j) 
		            	    				& (inMSet m (mu (config (rho T j)))) 
		            	    				& (ready-to (rho T j) x (receive x m))
		            	    			)
	            	    	)			              
	            	) 
    		)
     	)

	(!prove nonfaulty->IOE-rcv-transformed [nonfaulty->IOE-rcv])	


    conclude IOE->Fair-Rcv-Theorem
    pick-any x:Actor
    pick-any m:Message
    pick-any T:TP 
    pick-any i:N 	
    assume (nonfaulty x)
    assume ((inMSet m (mu (config (rho T i)))) & (ready-to (rho T i) x (receive x m)))
    let{
     	NFx := (nonfaulty x);
    	inRT := ((inMSet m (mu (config (rho T i)))) & (ready-to (rho T i) x (receive x m)));
     	IOE-axiom := (!uspec (!uspec (!uspec (!uspec nonfaulty->IOE-rcv-transformed x) m) T) i);
     	IOE-disjunction := (!mp IOE-axiom (!both NFx inRT));
     	FAIR-axiom := (!uspec (!uspec (!uspec (!uspec F-Rcv-Axm x) m) T) i);
     	FAIR-disjunction :=  (!mp FAIR-axiom inRT);
		IOE-rd := (forall k .  (i N.< k)
						==>
						(exists j .
		    				  (k N.<= j) 
		    				& (inMSet m (mu (config (rho T j)))) 
		    				& (ready-to (rho T j) x (receive x m))
		    			)
			      );
        FAIR-rd:=   (exists k . (i N.< k)
        	    			& (forall j .
        	    			   (k N.<= j)
        	    			     ==>
        	    			     	(~(
	            	    			   (inMSet m (mu (config (rho T j)))) 
	            	    			 & (ready-to (rho T j) x (receive x m))		            	    			     		
        	    			     	 ))
        	    			  )

        	        )	
    }
    (!by-contradiction (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (receive x m))) )
    	assume (~ (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (receive x m))) ))
    		let{ 
    			assump := (~ (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (receive x m))) ));
    			IOE-cond-def := (!cond-def IOE-disjunction);
    			IOE-rd-true := (!mp IOE-cond-def assump);
    			FAIR-cond-def := (!cond-def FAIR-disjunction);
    			FAIR-rd-true := (!mp FAIR-cond-def assump);
    			IOE-rd-contra-FAIR-rd := (!uspec (!uspec (!uspec (!uspec IOErcv-FAIRrcv-rd-absurd x) m) T) i);
    			FAIR-rd-false := (!mp (!left-iff IOE-rd-contra-FAIR-rd) IOE-rd-true)
    		}	
    (!absurd FAIR-rd-true FAIR-rd-false) 		
    )
    # Alternative
	# (!prove IOE->Fair-Rcv-Theorem [nonfaulty->IOE-rcv-transformed F-Rcv-Axm IOErcv-FAIRrcv-rd-absurd])	



	define Fair-Rcv-Causes-Theorem :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((inMSet m (mu (config (rho T i)))) 
				        & (ready-to (rho T i) x (receive x m)))  
			            	==>
				            	(exists j . (i N.<= j) 
		            	    				& (inMSet m (amu (als (config (rho T j)) x))))  						
					)

             )

	define Fair-Rcv-Causes-Theorem-step1 :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((inMSet m (mu (config (rho T i)))) 
				        & (ready-to (rho T i) x (receive x m)))  
			            	==>
				            	(exists j k . (i N.<= j)
				            				& (j N.<= k) 
				            				& (= (rho T k) (then (rho T j) (receive x m)))  						
		            	    				& (= (rho T (S j)) (then (rho T j) (receive x m)))) 						
					)
             )	

    (!prove Fair-Rcv-Causes-Theorem-step1 [IOE->Fair-Rcv-Theorem N.Less=.S3])

	define Fair-Rcv-Causes-Theorem-step2 :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((inMSet m (mu (config (rho T i)))) 
				        & (ready-to (rho T i) x (receive x m)))  
			            	==>
				            	(exists j k . (i N.<= j)
				            				& (j N.<= k) 
				            				& (= (rho T k) (then (rho T j) (receive x m)))  						
		            	    				& (= (rho T (S j)) (then (rho T j) (receive x m)))
		            	    				& (inMSet m (amu (als (config (rho T k)) x)))) 						
					)
             )	

    (!prove Fair-Rcv-Causes-Theorem-step2 [Fair-Rcv-Causes-Theorem-step1 model-step-axioms])


    (!prove Fair-Rcv-Causes-Theorem [Fair-Rcv-Causes-Theorem-step2 N.Less=.transitive])

#----------------------------------------------------------------------------
	#-- Fair-send: If at any index in a transition path, a send transition is enabled
	#-- for an actor that is IOE,then it eventually happens at some index in the same path     
	define IOE->Fair-Snd-Theorem :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((ready-to (rho T i) x (send x m)))  
			            	==>
				            	(exists j . (i N.<= j) 
		            	    				& (= (rho T (S j)) (then (rho T j) (send x m))) ) 						
					)

             )	

	define IOEsnd-FAIRsnd-rd-absurd :=
		(forall x m T i .
	       (forall k .  (i N.< k)
	    				==>
	    				(exists j .
    	    				  (k N.<= j) 
    	    				& (ready-to (rho T j) x (send x m))
    	    			)
	    	)
    	    	<==>
    	     (~ (exists k . (i N.< k)
    	    			 & (forall j .
    	    			   (k N.<= j)
    	    			     ==>
    	    			     	(~((ready-to (rho T j) x (send x m))))
    	    			   )

    	       ))   		
     	)

	(!prove IOEsnd-FAIRsnd-rd-absurd [])

	define IOE-FAIRNESS-LD-same-snd :=
	(forall x m T i .
		 (= (rho T (S i)) (then (rho T i) (send x m))) 
		 ==> 
		  (exists j . (i N.<= j) 
		   			& (= (rho T (S j)) (then (rho T j) (send x m))) )
	)

	conclude IOE-FAIRNESS-LD-same-snd
    pick-any x:Actor
    pick-any m:Message
    pick-any T:TP 
    pick-any i:N 	
    assume (= (rho T (S i)) (then (rho T i) (send x m)))
    let{
		ld := (= (rho T (S i)) (then (rho T i) (send x m)));
		rd := (exists j . (i N.<= j) 
		   	& (= (rho T (S j)) (then (rho T j) (send x m))) );
		i<=Si := (!uspec N.Less=.reflexive i);
		_ := (!both i<=Si ld)
    }	
    (!egen rd i)

	define nonfaulty->IOE-snd-transformed :=
		(forall x  m T i .
			(
		        (  (nonfaulty x)
		         & (ready-to (rho T i) x (send x m)))  
	            	==>
	            	(
						  (exists j . (i N.<= j) 
						   			& (= (rho T (S j)) (then (rho T j) (send x m))) )                
	            	    |  (forall k .  (i N.< k)
	            	    				==>
	            	    				(exists j .
		            	    				  (k N.<= j) 
		            	    				& (ready-to (rho T j) x (send x m))
		            	    			)
	            	    	)			              
	            	) 
    		)
     	)

	(!prove nonfaulty->IOE-snd-transformed [nonfaulty->IOE-snd])	

    conclude IOE->Fair-Snd-Theorem
    pick-any x:Actor
    pick-any m:Message
    pick-any T:TP 
    pick-any i:N 	
    assume (nonfaulty x)
    assume (ready-to (rho T i) x (send x m))
    let{
     	NFx := (nonfaulty x);
    	inRT := (ready-to (rho T i) x (send x m));
     	IOE-axiom := (!uspec (!uspec (!uspec (!uspec nonfaulty->IOE-snd-transformed x) m) T) i);
     	IOE-disjunction := (!mp IOE-axiom (!both NFx inRT));
     	FAIR-axiom := (!uspec (!uspec (!uspec (!uspec F-Snd-Axm x) m) T) i);
     	FAIR-disjunction :=  (!mp FAIR-axiom inRT);
		IOE-rd := (forall k . (i N.< k)
						==>
						(exists j .
		    				  (k N.<= j) 
		    				& (ready-to (rho T j) x (send x m))
		    			)
			      );
        FAIR-rd:=   (exists k . (i N.< k)
        	    			& (forall j .
        	    			   (k N.<= j)
        	    			     ==>
        	    			     	(~((ready-to (rho T j) x (send x m))))
        	    			  )

        	        )	
    }
    (!by-contradiction (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (send x m))) )
    	assume (~ (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (send x m))) ))
    		let{ 
    			assump := (~ (exists j . (i N.<= j) & (= (rho T (S j)) (then (rho T j) (send x m))) ));
    			IOE-cond-def := (!cond-def IOE-disjunction);
    			IOE-rd-true := (!mp IOE-cond-def assump);
    			FAIR-cond-def := (!cond-def FAIR-disjunction);
    			FAIR-rd-true := (!mp FAIR-cond-def assump);
    			IOE-rd-contra-FAIR-rd := (!uspec (!uspec (!uspec (!uspec IOEsnd-FAIRsnd-rd-absurd x) m) T) i);
    			FAIR-rd-false := (!mp (!left-iff IOE-rd-contra-FAIR-rd) IOE-rd-true)
    		}	
    (!absurd FAIR-rd-true FAIR-rd-false) 		
    )

	define Fair-Snd-Causes-Theorem :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((ready-to (rho T i) x (send x m)))  
			            	==>
				            	(exists j . (i N.<= j) 
		            	    				& (inMSet m (mu (config (rho T j))) )
								)  						
					)

             )

	define Fair-Snd-Causes-Theorem-step1 :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((ready-to (rho T i) x (send x m)))  
			            	==>
				            	(exists j k . (i N.<= j)
				            				& (j N.<= k) 
				            				& (= (rho T k) (then (rho T j) (send x m)))  						
		            	    				& (= (rho T (S j)) (then (rho T j) (send x m)))) 						
					)
             )	

    (!prove Fair-Snd-Causes-Theorem-step1 [IOE->Fair-Snd-Theorem N.Less=.S3])

	define Fair-Snd-Causes-Theorem-step2 :=
			(forall x m T i .
				(nonfaulty x) 
					==>
					(
				        ((ready-to (rho T i) x (send x m)))  
			            	==>
				            	(exists j k . (i N.<= j)
				            				& (j N.<= k) 
				            				& (= (rho T k) (then (rho T j) (send x m)))  						
		            	    				& (= (rho T (S j)) (then (rho T j) (send x m)))
		            	    				& (inMSet m (mu (config (rho T k))) )
) 						
					)
             )	

    (!prove Fair-Snd-Causes-Theorem-step2 [Fair-Snd-Causes-Theorem-step1 model-step-axioms])


    (!prove Fair-Snd-Causes-Theorem [Fair-Snd-Causes-Theorem-step2 N.Less=.transitive])



#----------------------------------------------------------------------------
#-- Message persistance proofs for different types of Synod messages

#-------- Multiset
	# Messages sent by agents in a good set persist until received
	define nonfaulty-msg-persists-until-read :=
			(forall T i a p typ b v .
				(
					(inMSet (consM p a typ b v) (mu (config (rho T i))))	
				  & (nonfaulty p)		
			    )
					==>
						(
							  (forall j .
							        (i N.<= j) 
							  		      ==> 
							  			     (inMSet (consM p a typ b v) (mu (config (rho T j)))) 
							  )

							| (exists k . (   (i N.<= k) 
		            	    				& (= (rho T (S k)) (then (rho T k) (receive a (consM p a typ b v))))
		            	    			  )
							  )
						)	
			)

    (!prove nonfaulty-msg-persists-until-read [msg-persists-until-read N.Less=.Implied-by-<])


	define nonfaulty-msg-persists-until-read-causes :=
			(forall T i a p typ b v .
				(
					(inMSet (consM p a typ b v) (mu (config (rho T i))))	
				  & (nonfaulty p)		
			    )
					==>
						(
							  (forall j .
							        (i N.<= j) 
							  		      ==> 
							  			     (inMSet (consM p a typ b v) (mu (config (rho T j)))) 
							  )

							| (exists k . (   (i N.<= k) 
		            	    				& (inMSet (consM p a typ b v) (amu (als (config (rho T k)) a)))
		            	    			  )
							  )
						)	
			)

	define nonfaulty-msg-persists-until-read-causes-step1 :=
			(forall T i a p typ b v .
				(
					(inMSet (consM p a typ b v) (mu (config (rho T i))))	
				  & (nonfaulty p)		
			    )
					==>
						(
							  (forall j .
							        (i N.<= j) 
							  		      ==> 
							  			     (inMSet (consM p a typ b v) (mu (config (rho T j)))) 
							  )

							| (exists k  u . (   (i N.<= k) 
		            	    				& (= (rho T (S k)) (then (rho T k) (receive a (consM p a typ b v))))
		            	    				& (k N.<= u)
		            	    				& (= (rho T u) (then (rho T k) (receive a (consM p a typ b v))))
		            	    			  )
							  )
						)	
			)

    (!prove nonfaulty-msg-persists-until-read-causes-step1 [nonfaulty-msg-persists-until-read N.Less=.S3])    

	define nonfaulty-msg-persists-until-read-causes-step2 :=
			(forall T i a p typ b v .
				(
					(inMSet (consM p a typ b v) (mu (config (rho T i))))	
				  & (nonfaulty p)		
			    )
					==>
						(
							  (forall j .
							        (i N.<= j) 
							  		      ==> 
							  			     (inMSet (consM p a typ b v) (mu (config (rho T j)))) 
							  )

							| (exists k  u . (   (i N.<= k) 
		            	    				& (= (rho T (S k)) (then (rho T k) (receive a (consM p a typ b v))))
		            	    				& (k N.<= u)
		            	    				& (= (rho T u) (then (rho T k) (receive a (consM p a typ b v))))
		            	    				& (inMSet (consM p a typ b v) (amu (als (config (rho T u)) a)))
		            	    			  )
							  )
						)	
			)

    (!prove nonfaulty-msg-persists-until-read-causes-step2 [nonfaulty-msg-persists-until-read-causes-step1 model-step-axioms])


	define nonfaulty-msg-persists-until-read-causes-step3 :=
			(forall T i a p typ b v .
				(
					(inMSet (consM p a typ b v) (mu (config (rho T i))))	
				  & (nonfaulty p)		
			    )
					==>
						(
							  (forall j .
							        (i N.<= j) 
							  		      ==> 
							  			     (inMSet (consM p a typ b v) (mu (config (rho T j)))) 
							  )

							| (exists k  u . (   (i N.<= k) 
		            	    				& (= (rho T (S k)) (then (rho T k) (receive a (consM p a typ b v))))
		            	    				& (k N.<= u)
		            	    				& (i N.<= u)
		            	    				& (= (rho T u) (then (rho T k) (receive a (consM p a typ b v))))
		            	    				& (inMSet (consM p a typ b v) (amu (als (config (rho T u)) a)))
		            	    			  )
							  )
						)	
			)

    (!prove nonfaulty-msg-persists-until-read-causes-step3 [nonfaulty-msg-persists-until-read-causes-step2 N.Less=.transitive])


    (!prove nonfaulty-msg-persists-until-read-causes [nonfaulty-msg-persists-until-read-causes-step3])


	define 1a-model-msg-persists-until-read-axiom-lemma :=
			(forall T i j p a b .
				(					
					(inMSet (consM p a 1a b nilV) (mu (config (rho T i))))
				 & (nonfaulty p)	
				)	
					==>
						(
							  ( (i N.<= j) 
							  		==> 
							  			(inMSet (consM p a 1a b nilV) (mu (config (rho T j)))) )
							| (exists k . (   (i N.<= k) 
		            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
		            	    			  )
							  )							
						)	

			)

		
	
	(!prove 1a-model-msg-persists-until-read-axiom-lemma [ nonfaulty-msg-persists-until-read-causes  N.Less=.Implied-by-<])		


	define 1b-model-msg-persists-until-read-axiom-lemma :=
			(forall T i j p a b v .
				(					
					(inMSet (consM a p 1b b v) (mu (config (rho T i))))
				 & (nonfaulty a)	
				)
					==>
						(
							  ( (i N.<= j) 
							  		==> 
							  			(inMSet (consM a p 1b b v) (mu (config (rho T j)))) )
							| (exists k . (   (i N.<= k) 
		            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T k)) p)))
		            	    			  )
							  )

						)	

			)

	
	(!prove 1b-model-msg-persists-until-read-axiom-lemma [ nonfaulty-msg-persists-until-read-causes  N.Less=.Implied-by-<])		


	define 2a-model-msg-persists-until-read-axiom-lemma :=
			(forall T i j p a b v .
				(					
					(inMSet (consM p a 2a b v) (mu (config (rho T i))))
				 & (nonfaulty p)	
				)
					==>
						(
							  ( (i N.<= j) 
							  		==> 
							  			(inMSet (consM p a 2a b v) (mu (config (rho T j)))) )
							| (exists k . (   (i N.<= k) 
		            	    				& (inMSet (consM p a 2a b v) (amu (als (config (rho T k)) a)))
		            	    			  )

							  )

						)	

			)

	(!prove 2a-model-msg-persists-until-read-axiom-lemma [ nonfaulty-msg-persists-until-read-causes  N.Less=.Implied-by-<])

	define 2b-model-msg-persists-until-read-axiom-lemma :=
			(forall T i j p a b v .
				(					
					(inMSet (consM a p 2b b v) (mu (config (rho T i))))
				 & (nonfaulty a)	
				)
					==>
						(
							  ( (i N.<= j) 
							  		==> 
							  			(inMSet (consM a p 2b b v) (mu (config (rho T j)))) )
							| (exists k . (   (i N.<= k) 
		            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T k)) p)))
		            	    			  )
		            	      )			  							
						)	

			)

	(!prove 2b-model-msg-persists-until-read-axiom-lemma [ nonfaulty-msg-persists-until-read-causes N.Less=.Implied-by-<])			

	define synod-msg-persistance-axioms := [1a-model-msg-persists-until-read-axiom-lemma 
							  				1b-model-msg-persists-until-read-axiom-lemma
							  				2a-model-msg-persists-until-read-axiom-lemma
							  				2b-model-msg-persists-until-read-axiom-lemma 
							  				]

#-------- Local unresponded set
	define persistent-unresponded-local-2a-msgs-causes :=
	(forall T i a p b v .
		(
		 (inMSet (consM p a 2a b v) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k . 
							(i N.<= k)
							& (inMSet (consM a p 2b b v) (mu (config (rho T k))) )

					  )
		)
    )


	define persistent-unresponded-local-2a-msgs-causes-step1 :=
	(forall T i a p b v .
		(
		 (inMSet (consM p a 2a b v) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k u . 
							(i N.<= k)
							& (= (rho T (S k)) (then (rho T k) (send a (consM a p 2b b v))))
							& (k N.<= u) 
							& (= (rho T u) (then (rho T k) (send a (consM a p 2b b v))))
					  )
		)
    )

    (!prove persistent-unresponded-local-2a-msgs-causes-step1 [persistent-unresponded-local-2a-msgs N.Less=.S3])


	define persistent-unresponded-local-2a-msgs-causes-step2 :=
	(forall T i a p b v .
		(
		 (inMSet (consM p a 2a b v) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k u . 
							(i N.<= k)
							& (= (rho T (S k)) (then (rho T k) (send a (consM a p 2b b v))))
							& (k N.<= u)
							& (i N.<= u) 
							& (= (rho T u) (then (rho T k) (send a (consM a p 2b b v))))
							& (inMSet (consM a p 2b b v) (mu (config (rho T u))) )
					  )
		)
    )

    (!prove persistent-unresponded-local-2a-msgs-causes-step2 [persistent-unresponded-local-2a-msgs-causes-step1 N.Less=.transitive model-step-axioms])
   
    (!prove persistent-unresponded-local-2a-msgs-causes [persistent-unresponded-local-2a-msgs-causes-step2])


	define persistent-unresponded-local-1a-msgs-causes :=
	(forall T i a p b .
		(
		 (inMSet (consM p a 1a b nilV) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k v . 
							(i N.<= k)
							& (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
					  )
		)
    )

	define persistent-unresponded-local-1a-msgs-causes-step1 :=
	(forall T i a p b .
		(
		 (inMSet (consM p a 1a b nilV) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k u . 
							(i N.<= k)
							& (= (rho T (S k)) (then (rho T k) (send a (consM a p 1b b (value (als (config (rho T k)) a))))))
							& (k N.<= u) 
							& (= (rho T u) (then (rho T k) (send a (consM a p 1b b (value (als (config (rho T k)) a))))))
					  )
		)
    )

    (!prove persistent-unresponded-local-1a-msgs-causes-step1 [persistent-unresponded-local-1a-msgs N.Less=.S3])


	define persistent-unresponded-local-1a-msgs-causes-step2 :=
	(forall T i a p b .
		(
		 (inMSet (consM p a 1a b nilV) (amu (als (config (rho T i)) a))) 
		 	==>
					  (forall j .
					        (i N.<= j) 
					  		      ==> 
					  			      (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
					  )
					| (exists k u . 
							(i N.<= k)
							& (= (rho T (S k)) (then (rho T k) (send a (consM a p 1b b (value (als (config (rho T k)) a))))))
							& (k N.<= u) 
							& (i N.<= u)
							& (= (rho T u) (then (rho T k) (send a (consM a p 1b b (value (als (config (rho T k)) a))))))
							& (inMSet (consM a p 1b b (value (als (config (rho T k)) a))) (mu (config (rho T u))) )
					  )
		)
    )

    (!prove persistent-unresponded-local-1a-msgs-causes-step2 [persistent-unresponded-local-1a-msgs-causes-step1 N.Less=.transitive model-step-axioms])
   
    (!prove persistent-unresponded-local-1a-msgs-causes [persistent-unresponded-local-1a-msgs-causes-step2])



#----------------------------------------------------------------------------
# Intermediate lemmas for ready-to receive behavior by message 


	define synod-ready-to-receive-lemma1a :=
		(forall T i b p a .
				  (	
					   (available (config (rho T i)) a)
					  & (inMSet (consM p a 1a b nilV) (mu (config (rho T i))))
				  )
					==>
						(ready-to (rho T i) a (receive a (consM p a 1a b nilV)))
					
		)

	(!prove synod-ready-to-receive-lemma1a [Rcv-Rul])

	define synod-ready-to-receive-lemma1b :=
		(forall T i b v p a .
				  (	
					    (available (config (rho  T i)) p)
					  & (inMSet (consM a p 1b b v) (mu (config (rho T i))))
				  )
					==>
						(ready-to (rho T i) p (receive p (consM a p 1b b v)))
					
		)

	(!prove synod-ready-to-receive-lemma1b [Rcv-Rul])


	define synod-ready-to-receive-lemma2a :=
		(forall T i b v p a .
				  (	
					    (available (config (rho T i )) a)
					  & (inMSet (consM p a 2a b v) (mu (config (rho T i))))
				  )
					==>
						(ready-to (rho T i) a (receive a (consM p a 2a b v)))
					
		)


	(!prove synod-ready-to-receive-lemma2a [Rcv-Rul])

	define synod-ready-to-receive-lemma2b :=
		(forall T i b p a v .
				  (	
					    (available (config (rho T i )) p)
					  & (inMSet (consM a p 2b b v) (mu (config (rho T i))))
				  )
					==>
						(ready-to (rho T i) p (receive p (consM a p 2b b v)))
					
		)

	(!prove synod-ready-to-receive-lemma2b [Rcv-Rul])

	define synod-ready-to-receive-lemmas := [ synod-ready-to-receive-lemma1a
								 			  synod-ready-to-receive-lemma1b
								  			  synod-ready-to-receive-lemma2a
								  			  synod-ready-to-receive-lemma2b
								  			]

#----------------------------------------------------------------------------
# Collecting responses from quorum 

	define collect-1b-from-quorum :=
	(forall T i p b Q .
	    (
  			(forall a . (inQ a Q) ==> (exists j v . (i N.<= j) & (inMSet (consM a p 1b b v) (amu (als (config (rho T j)) p))) ))
			==>
				(exists k . (i N.<= k) 
					      & (forall a . (inQ a Q) ==> (exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T k)) p))) )) )
	  	)					  
    )

	define collect-2b-from-quorum :=
	(forall T i p b Q .
	    (
  			(forall a . (inQ a Q) ==> (exists j v . (i N.<= j) & (inMSet (consM a p 2b b v) (amu (als (config (rho T j)) p))) ))
			==>
				(exists k . (i N.<= k) 
					      & (forall a . (inQ a Q) ==> (exists v . (inMSet (consM a p 2b b v) (amu (als (config (rho T k)) p))) )) )
	  	)					  
    )


	(!prove collect-1b-from-quorum [received-from-quorum-general])
	(!prove collect-2b-from-quorum [received-from-quorum-general])



#----------------------------------------------------------------------------
# Intermediate lemmas for P1-P2-true behavior of a proposal number 


 	define P1+P2-True-1a-beta :=                                                                  
 		(forall b . 
 			 	(P1+P2-True b)                                                                    
				 ==> 
				 	(forall p T a i .
				 		(
					 		(
					 			  (acc a) 
						 		& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T i)) a))) 
							)
							==>	((beta (als (config (rho T i)) a)) < b) # In an actual implementation, the beta will be updated after responding to a message
				 		)												# and if a message has been responded to, it will be removed from local state
				 	)													# Therefore, this cannot lead to a fallacy when beta is updated
		)		 	

	(!prove P1+P2-True-1a-beta [P1-P2-Def])	

 	define P1+P2-True-2a-beta :=
 		(forall b . 
 			(P1+P2-True b)
				 ==> 
				 	(forall p T a i v .
				 		(
					 		(
					 			  (acc a) 
						 		& (inMSet (consM p a 2a b v) (amu (als (config (rho T i)) a))) 
							)
							==>	((beta (als (config (rho T i)) a)) =< b)
						) 
				 	)
	 	)

	(!prove P1+P2-True-2a-beta [P1-P2-Def])	

#----------------------------------------------------------------------------
# Some consequences of the syntactic sugar predicate definitions

 	define CND-def :=
	(forall T i p b Q .
		(
					  (prp p) 
					& (P1+P2-True b)
					& (nonfaulty p) 
					& ((all-inQ-NF Q) & (rdy2snd-1a-all-inQ p Q (rho T i) b))

		)

		==> 

		(
					  (prp p) 
					& (P1+P2-True b)
					& (nonfaulty p) 
					& (forall a . (inQ a Q) 
						                ==> 
						                      (nonfaulty a) 
						                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
					  )
		)

	)

	(!prove CND-def [symbol-defs])

#----------------------------------------------------------------------------
# Some intermediate Lemmas 



	#-- Lemma1a
	#-- In a fair transition path, if eventually a nonfaulty proposer P becomes ready to propose a ballot b that satisfies P1+P2-True, 
	#-- to a quorum Q of nonfaulty acceptors, then the 1a messages will be eventually received by all members of Q
	#------------------------------------------------------------------------

	define Lemma1a := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				( 
					(forall a .
						(inQ a Q) 
						     ==> 
								(exists j .
											 (i N.<= j) 
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
								)	       
					)	
				) 
	)



	define Lemma1a-step1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					(inQ a Q) 
						     ==> 
							(exists j . (i N.<= j) 
						        	  & (= (rho T (S j)) (then (rho T j) (send p (consM p a 1a b nilV)))) )	
				) 
	)


	(!prove Lemma1a-step1 [IOE->Fair-Snd-Theorem])


	define Lemma1a-step2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(exists j k . (i N.<= j)
										  & (j N.<= k)
										  & (= (rho T k) (then (rho T j) (send p (consM p a 1a b nilV)))) 
							        	  & (= (rho T (S j)) (then (rho T j) (send p (consM p a 1a b nilV)))) )	       
								)	
				) 
	)


	(!prove Lemma1a-step2 [Lemma1a-step1 N.Less=.S3])

	define Lemma1a-step2_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(exists j k . (i N.<= j)
										  & (j N.<= k)
										  & (i N.<= k)
										  & (= (rho T k) (then (rho T j) (send p (consM p a 1a b nilV)))) 
							        	  & (= (rho T (S j)) (then (rho T j) (send p (consM p a 1a b nilV)))) )	       
								)	
				) 
	)


	(!prove Lemma1a-step2_1 [Lemma1a-step2 N.Less=.transitive])


	define Lemma1a-step3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a . 
					((inQ a Q) 
						==> 
								(exists j k . (i N.<= k) 
							        	  & (= (rho T k) (then (rho T j) (send p (consM p a 1a b nilV))))
							        	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T k)))) 
							    )	       
					)	
				) 
	)


	(!prove Lemma1a-step3 [Lemma1a-step2_1 model-step-axioms])	




	define Lemma1a-step4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 	(nonfaulty a) & (acc a)
							  & (exists j . (i N.<= j) 
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))

							    )	       
					)	
				) 
	)


	(!prove Lemma1a-step4 [Lemma1a-step3 synod-quorum-axioms])


	define Lemma1a-step5 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j) 
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
				        	  		      & (
				        	  		  		  (available (config (rho T j )) a)

				    		    	  		| (exists k .
			                                             (j N.< k)
				    		    	  				   & (available (config (rho T k )) a))
				    		    	  	    )	 
							    )	       
					)	
				) 
	)


	(!prove Lemma1a-step5 [Lemma1a-step4 acceptor-nonfaulty1])


	define Lemma1a-step6 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
				        	  		      & (
				        	  		      	  (
					        	  		      	  	(available (config (rho T j )) a)
					        	  		      	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))	
				        	  		      	  )
				    		    	  		| (exists k .
			                                             (j N.<= k)
				    		    	  				   & (available (config (rho T k )) a)
				    		    	  		  )
				    		    	  	    )							        	  	 
							    )	       
					)	
				) 
	)


	(!prove Lemma1a-step6 [Lemma1a-step5 N.Less=.Implied-by-<])	


	define Lemma1a-step7 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
				        	  		      & (
				        	  		      	  (
					        	  		      	  	(available (config (rho T j )) a)
					        	  		      	  & (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))	
				        	  		      	  )
				    		    	  		| (exists k .
			                                             (j N.<= k)
				    		    	  				   & (available (config (rho T k )) a)
   													   & (
					            	    		  		  (inMSet (consM p a 1a b nilV) (mu (config (rho T k))))
														| (exists l . (   (j N.<= l) 
									            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
									            	    			  )
									            	      )						            	    		  		

				            	    		  	         )				    		    	  				   
				    		    	  		  )
				    		    	  	    )							        	  	 
							    )	       
					)	
				) 
	)

	(!prove Lemma1a-step7 [Lemma1a-step6 synod-msg-persistance-axioms])


	define Lemma1a-step8 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j) 
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (
							        	  		  (   #(~(lock (als (config (rho T j)) a)))
							        	  		  	 (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
							        	  		  	& (nonfaulty a)
							        	  		  	& (acc a)
							        	  		  	& (available (config (rho T j )) a)
							        	  		  )	

							        	  		| (exists k . (j N.<= k)
										  				   #& ~(lock (als (config (rho T k)) a))
  	   							        	  		  	   #& (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
  	   													   & (
							            	    		  		 (  
							            	    		  		   (inMSet (consM p a 1a b nilV) (mu (config (rho T k))))
							            	    		  		 #& (~(lock (als (config (rho T k)) a)))
							            	    		  		 & (nonfaulty a)
							            	    		  		 & (acc a)
							            	    		  		 & (available (config (rho T k )) a)  
							            	    		  		 )

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step8 [Lemma1a-step7 synod-quorum-axioms])	


	define Lemma1a-step9 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (
							        	  		  (   #(~(lock (als (config (rho T j)) a)))
							        	  		  	  (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
							        	  		  	& (nonfaulty a)
							        	  		  	& (available (config (rho T j )) a)
							        	  		  )	

							        	  		| (exists k . (j N.<= k)
										  				   #& ~(lock (als (config (rho T k)) a))
  	   							        	  		  	   #& (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
  	   													   & (
							            	    		  		 (  
							            	    		  		   (inMSet (consM p a 1a b nilV) (mu (config (rho T k))))
							            	    		  		 #& (~(lock (als (config (rho T k)) a)))
							            	    		  		 & (nonfaulty a)
							            	    		  		 & (available (config (rho T k )) a)  
							            	    		  		 )

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step9 [Lemma1a-step8 acceptor-nonfaulty1])	

	define Lemma1a-step10 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (
							        	  		  (  # (~(lock (als (config (rho T j)) a)))
							        	  		  	 (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
							        	  		  	& (nonfaulty a)
							        	  		  	& (available (config (rho T j )) a)
							        	  		  	& (ready-to (rho T j) a (receive a (consM p a 1a b nilV)))
							        	  		  )	

							        	  		| (exists k . (j N.<= k)
										  				   #& ~(lock (als (config (rho T k)) a))
  	   							        	  		  	   #& (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
  	   													   & (
							            	    		  		 (  
							            	    		  		   (inMSet (consM p a 1a b nilV) (mu (config (rho T k))))
							            	    		  		# & (~(lock (als (config (rho T k)) a)))
							            	    		  		 & (nonfaulty a)
							            	    		  		 & (available (config (rho T k )) a)
							            	    		  		 & (ready-to (rho T k) a (receive a (consM p a 1a b nilV)))  
							            	    		  		 )

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10 [Lemma1a-step9 synod-ready-to-receive-lemmas synod-quorum-axioms])


	define Lemma1a-step10_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  #& (= (rho T j) (then (rho T i) (send p (consM p a 1a b nilV))))
							        	  & (
							        	  		  (  # (~(lock (als (config (rho T j)) a)))
							        	  		  	 (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
							        	  		  	& (nonfaulty a)
							        	  		  	& (available (config (rho T j )) a)
							        	  		  	& (ready-to (rho T j) a (receive a (consM p a 1a b nilV)))
						            	    		& (exists z .
		            	    		  	      			  (j N.<= z) 
				            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T z)) a)))
						            	    		  )							        	  		  	
							        	  		  )	

							        	  		| (exists k y . (j N.<= k)
										  				   #& ~(lock (als (config (rho T k)) a))
  	   							        	  		  	   #& (inMSet (consM p a 1a b nilV) (mu (config (rho T j))))
  	   													   & (
							            	    		  		 (  
							            	    		  		   (inMSet (consM p a 1a b nilV) (mu (config (rho T k))))
							            	    		  		# & (~(lock (als (config (rho T k)) a)))
							            	    		  		 & (nonfaulty a)
							            	    		  		 & (available (config (rho T k )) a)
							            	    		  		 & (ready-to (rho T k) a (receive a (consM p a 1a b nilV)))
										            	    		 & (
							            	    		  	      			  (k N.<= y) 
									            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T y)) a)))									            	    		    
										            	    		   )							            	    		  		   
							            	    		  		 )

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10_1 [Lemma1a-step10 Fair-Rcv-Causes-Theorem])



	define Lemma1a-step10_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  & (
							        	  		  (  
						            	    		  (exists z .
		            	    		  	      			  (j N.<= z) 
				            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T z)) a)))
						            	    		  )							        	  		  	
							        	  		  )	

							        	  		| (exists k y . (j N.<= k)
  	   													   & (

										            	    		   (
							            	    		  	      			  (k N.<= y) 
									            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T y)) a)))									            	    		    
										            	    		   )							            	    		  		   
							            	    		  		 

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10_2 [Lemma1a-step10_1 ])


	define Lemma1a-step10_3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  & (
							        	  		  (  
						            	    		  (exists z .
		            	    		  	      			  (j N.<= z) 
				            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T z)) a)))
						            	    		  )							        	  		  	
							        	  		  )	

							        	  		| (exists k y . (j N.<= k)
  	   													   & (

										            	    		   (
							            	    		  	      			  (k N.<= y) 
									            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T y)) a)))									            	    		    
										            	    		   )							            	    		  		   
							            	    		  		 

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))
											            	    			  )
											            	      )	

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10_3 [Lemma1a-step10_2 model-step-axioms])


	define Lemma1a-step10_4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  & (
							        	  		  (  
						            	    		  (exists z .
		            	    		  	      			  (j N.<= z)
		            	    		  	      			& (i N.<= z)   
				            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T z)) a)))
						            	    		  )							        	  		  	
							        	  		  )	

							        	  		| (exists k y . (j N.<= k)
  	   													   & (

										            	    		   (
							            	    		  	      			  (k N.<= y)
							            	    		  	      			& (j N.<= y)   
									            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T y)) a)))									            	    		    
										            	    		   )							            	    		  		   
							            	    		  		 

							            	    		  		| (exists l . (j N.<= l)
							            	    		  					& (i N.<= l)
								            	    				        & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))   
													  			  )

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10_4 [Lemma1a-step10_3 N.Less=.transitive])	


	define Lemma1a-step10_5 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j .
							        	   (
							        	  		  (  
						            	    		  (exists z .
		            	    		  	      			  (i N.<= z)   
				            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T z)) a)))
						            	    		  )							        	  		  	
							        	  		  )	

							        	  		| (exists y .
  	   													     (

										            	    		   (
							            	    		  	      			  (j N.<= y)
							            	    		  	      			& (i N.<= y)     
									            	    					& (inMSet (consM p a 1a b nilV) (amu (als (config (rho T y)) a)))									            	    		    
										            	    		   )							            	    		  		   
							            	    		  		 

							            	    		  		| (exists l . (i N.<= l)
								            	    				        & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T l)) a)))   
													  			  )

						            	    		  	      )

										  		  )	   
							        	  	) 
							      )	       
					)	
				) 
	)


	(!prove Lemma1a-step10_5 [Lemma1a-step10_4 N.Less=.transitive])	



	define Lemma1a-step15 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))   
							    )	       
					)	
				) 
	)


	(!prove Lemma1a-step15 [Lemma1a-step10_5])

	(!prove Lemma1a [Lemma1a-step15])	


	#-- Lemma1b 
	#-- In a fair transition path, if eventually a nonfaulty proposer P becomes ready to propose a ballot b that satisfies P1+P2-True, 
	#-- to a quorum Q of nonfaulty acceptors, then 1b messages will be eventually received by P from all members of Q for the ballot b
	#------------------------------------------------------------------------	 
		

	define Lemma1b := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
  							(exists j .
  									  (i N.<= j)	
						  			& (has-promises (als (config (rho T j)) p) b  Q) 
  							)
	)		



	define Lemma1b-step1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
							        	  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))
							        	  & (acc a)   
							    )	       
					)	
				) 
	)


	(!prove Lemma1b-step1 [Lemma1a synod-quorum-axioms])


	define Lemma1b-step2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b) 	
								)        
					)	
				) 
	)


	(!prove Lemma1b-step2 [Lemma1b-step1 P1+P2-True-1a-beta])



	define Lemma1b-step3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
									       & (
												(available (config (rho T j )) a)
													==>
														 (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
									       	 )
								)        
					)	
				) 
	)


	(!prove Lemma1b-step3 [Lemma1b-step2 Snd-Ruls])	


 

	define Lemma1b-step4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
									       & (nonfaulty a)
									       #& (available (config (rho T j )) a)
									       & (
												(available (config (rho T j )) a)
													==>
														 (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
									       	 )
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step4 [Lemma1b-step3])		



	define Lemma1b-step5 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
				        	  		       & (
					        	  		  		  (available (config (rho T j )) a)

					    		    	  		| (exists k .
				                                             (j N.< k)
					    		    	  				   & (available (config (rho T k )) a))
				    		    	  	     )
									       & (
												(available (config (rho T j )) a)
													==>
														 (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
									       	 )
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step5 [Lemma1b-step4 acceptor-nonfaulty2])	


	define Lemma1b-step5_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
				        	  		       & (
										         (
													(available (config (rho T j )) a)
												  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
										       	 )

					    		    	  		| (exists k .
				                                             (j N.< k)
					    		    	  				   & (available (config (rho T k )) a))
				    		    	  	     )
									       & (
												(available (config (rho T j )) a)
													==>
														 (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
									       	 )
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step5_1 [Lemma1b-step5])

	define Lemma1b-step5_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
				        	  		       & (
				        	  		       		(
				        	  		       			(available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )	

				        	  		       	    )
					    		    	  		| (exists k .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (available (config (rho T k )) a)
					    		    	  		  )
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step5_2 [Lemma1b-step5_1 N.Less=.Implied-by-< collect-1b-from-quorum N.Less=.transitive])

	define Lemma1b-step6 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
				        	  		       & (
				        	  		       		(
				        	  		       			(available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )	

				        	  		       	    )
					    		    	  		| (exists k .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (available (config (rho T k )) a)
					    		    	  				   & (
					    		    	  				   	      (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))


																	| (exists u v2 . 
																			(j N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )

					    		    	  				   	 )
					    		    	  		  )
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step6 [Lemma1b-step5_2 persistent-unresponded-local-1a-msgs-causes])




	define Lemma1b-step6_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . (i N.<= j)
									       & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a))) 
									       & (acc a)
									       & ((beta (als (config (rho T j)) a)) < b)
				        	  		       & (
				        	  		       		(
				        	  		       			(available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )	

				        	  		       	    )
					    		    	  		| (exists k .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (available (config (rho T k )) a)
								    		    	  				   & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
								    		    	  				   & ((beta (als (config (rho T k)) a)) < b)
					    		    	  				   	      )

																	| (exists u v2 . 
																			(j N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step6_1 [Lemma1b-step6 P1+P2-True-1a-beta])



	define Lemma1b-step6_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & (exists j . 
				        	  		         (
				        	  		       		(   (i N.<= j)
				        	  		       		  & (available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
				        	  		       		  & ((beta (als (config (rho T j)) a)) < b)
				        	  		       		  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))	

				        	  		       	    )
					    		    	  		| (exists k .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (available (config (rho T k )) a)
								    		    	  				   & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
								    		    	  				   & ((beta (als (config (rho T k)) a)) < b)
								    		    	  				   & (ready-to (rho T k) a (send a (consM a p 1b b (value (als (config (rho T k)) a))) ) )
					    		    	  				   	      )

																	| (exists u v2 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step6_2 [Lemma1b-step6_1 Snd-Ruls N.Less=.Implied-by-< N.Less=.transitive])


	define Lemma1b-step6_3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists j .
				        	  		       		(   (i N.<= j)
				        	  		       		  & (available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
				        	  		       		  & ((beta (als (config (rho T j)) a)) < b)
				        	  		       		  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))	

				        	  		       	    )
					    		    	  		| (exists k .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (available (config (rho T k )) a)
								    		    	  				   & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
								    		    	  				   & ((beta (als (config (rho T k)) a)) < b)
								    		    	  				   & (ready-to (rho T k) a (send a (consM a p 1b b (value (als (config (rho T k)) a))) ) )
					    		    	  				   	      )

																	| (exists u v2 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step6_3 [Lemma1b-step6_2 ])



	define Lemma1b-step7 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists j y .
				        	  		       		(   (i N.<= j)
				        	  		       		  & (available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
				        	  		       		  & ((beta (als (config (rho T j)) a)) < b)
				        	  		       		  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))	
			    		    	  				   & (j N.<= y)
			    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T j)) a))) (mu (config (rho T y))) )
				        	  		       	    )
					    		    	  		| (exists k z .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (available (config (rho T k )) a)
								    		    	  				   & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
								    		    	  				   & ((beta (als (config (rho T k)) a)) < b)
								    		    	  				   & (ready-to (rho T k) a (send a (consM a p 1b b (value (als (config (rho T k)) a))) ) )
								    		    	  				   & (k N.<= z)
								    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T k)) a))) (mu (config (rho T z))) )
					    		    	  				   	      )

																	| (exists u v2 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step7 [Lemma1b-step6_3 Fair-Snd-Causes-Theorem])




	define Lemma1b-step7_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists j y .
				        	  		       		(   (i N.<= j)
				        	  		       		  & (available (config (rho T j )) a)
				        	  		       		  & (ready-to (rho T j) a (send a (consM a p 1b b (value (als (config (rho T j)) a))) ) )
				        	  		       		  & ((beta (als (config (rho T j)) a)) < b)
				        	  		       		  & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T j)) a)))	
			    		    	  				   & (j N.<= y)
			    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T j)) a))) (mu (config (rho T y))) )
				        	  		       	    )
					    		    	  		| (exists k z .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (available (config (rho T k )) a)
								    		    	  				   & (inMSet (consM p a 1a b nilV) (amu (als (config (rho T k)) a)))
								    		    	  				   & ((beta (als (config (rho T k)) a)) < b)
								    		    	  				   & (ready-to (rho T k) a (send a (consM a p 1b b (value (als (config (rho T k)) a))) ) )
								    		    	  				   & (k N.<= z)
								    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T k)) a))) (mu (config (rho T z))) )
					    		    	  				   	      )
																	| (exists u v2 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step7_1 [Lemma1b-step7 model-step-axioms])
	

	define Lemma1b-step7_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists j y .
				        	  		       		(   (i N.<= j)
			    		    	  				   & (j N.<= y)
			    		    	  				   & (i N.<= y)
			    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T j)) a))) (mu (config (rho T y))) )
				        	  		       	    )
					    		    	  		| (exists k z .
				                                             (j N.<= k)
				                                           & (i N.<= k)  
					    		    	  				   & (
					    		    	  				   	      (
								    		    	  				     (k N.<= z)
								    		    	  				   & (i N.<= z)  
								    		    	  				   & (inMSet (consM a p 1b b (value (als (config (rho T k)) a))) (mu (config (rho T z))) )
					    		    	  				   	      )

																	| (exists u v2 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v2) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step7_2 [Lemma1b-step7_1 N.Less=.transitive])	


	define Lemma1b-step7_3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists v y .
				        	  		       		(   (i N.<= y)
			    		    	  				   & (inMSet (consM a p 1b b v) (mu (config (rho T y))) )
				        	  		       	    )
					    		    	  		| (exists z v2 .
				                                             
					    		    	  				    (
					    		    	  				   	      (      (i N.<= z)  
								    		    	  				   & (inMSet (consM a p 1b b v2) (mu (config (rho T z))) )
					    		    	  				   	      )
																	| (exists u v3 . 
																			(j N.<= u)
																			& (i N.<= u)
																			& (inMSet (consM a p 1b b v3) (mu (config (rho T u))) )
																	  )
															  )	


					    		    	  		  )					    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step7_3 [Lemma1b-step7_2])


	define Lemma1b-step7_4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
							  & ( 
				        	  		         (exists v y .
				        	  		       		(   (i N.<= y)
			    		    	  				   & (inMSet (consM a p 1b b v) (mu (config (rho T y))) )
				        	  		       	    )				    		    	  		
				    		    	  	     )			        	  		       
									       	 
								 )         
					)	
				) 
	)


	(!prove Lemma1b-step7_4 [Lemma1b-step7_3])


	define Lemma1b-step8_4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 
								& (exists v k .
											 (i N.<= k) 
			            	    		   & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )  									             	 
								  )          
					)	
				) 
	)


	(!prove Lemma1b-step8_4 [Lemma1b-step7_4])	



	define Lemma1b-step10 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k) 
			            	    		   & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )  									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step10 [Lemma1b-step8_4])	



	define Lemma1b-step13 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k) 
				            	    	   & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
				        	  		       & (
					        	  		  		  (available (config (rho T k )) p)

					    		    	  		| (exists j .
				                                             (k N.< j)
					    		    	  				   & (available (config (rho T j )) p))
				    		    	  	     )				            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step13 [Lemma1b-step10 proposer-nonfaulty1])	



	define Lemma1b-step14 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k) 
				            	    	   & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
				        	  		       & (
				        	  		       		  (
				        	  		       		  	  (available (config (rho T k )) p)	
				        	  		       		  	& (inMSet (consM a p 1b b v) (mu (config (rho T k))) )	
				        	  		       		  )
					        	  		  		  

					    		    	  		| (exists j .
				                                             (k N.<= j)
					    		    	  				   & (available (config (rho T j )) p)
					    		    	  		  )
				    		    	  	     )

								  )         
					)	
				) 
	)


	(!prove Lemma1b-step14 [Lemma1b-step13 N.Less=.Implied-by-<])


	define Lemma1b-step15 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k)
										   & (inMSet (consM a p 1b b v) (mu (config (rho T k))))	  
				        	  		       & (
				        	  		       		  (
				        	  		       		  	  (available (config (rho T k )) p)	
				        	  		       		  	& (inMSet (consM a p 1b b v) (mu (config (rho T k))) )	
				        	  		       		  )
					        	  		  		  
				    		    	  		| (exists j .
			                                             (k N.<= j)
				    		    	  				   & (available (config (rho T j )) p)
				    		    	  				   & (inMSet (consM a p 1b b v) (mu (config (rho T k))))
   													   & (
					            	    		  		  (inMSet (consM a p 1b b v) (mu (config (rho T j))))
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )						            	    		  		

				            	    		  	         )				    		    	  				   
				    		    	  		  )
				    		    	  	     )			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step15 [Lemma1b-step14 1b-model-msg-persists-until-read-axiom-lemma])


	define Lemma1b-step18 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k)
							        	   & (
							        	   		  (
							        	  		       #(~(lock (als (config (rho T k)) p)))
							        	   		  	  (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
							        	   		  	 & (available (config (rho T k )) p)
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)

							        	   		  	 & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
												     & (
												     		   (
												     		   	      (inMSet (consM a p 1b b v) (mu (config (rho T j))))
							        	  		     				#& (~(lock (als (config (rho T j)) p)))
							        	  		     				& (available (config (rho T j )) p)
												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step18 [Lemma1b-step15 proposer-nonfaulty1])	



	define Lemma1b-step19 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k)
							        	   & (
							        	   		  (
							        	  		       #(~(lock (als (config (rho T k)) p)))
							        	   		  	  (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
							        	   		  	 & (available (config (rho T k )) p)
							        	   		  	 & (ready-to (rho T k) p (receive p (consM a p 1b b v)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)

							        	   		  	 & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
												     & (
												     		   (
												     		   	      (inMSet (consM a p 1b b v) (mu (config (rho T j))))
							        	  		     				#& (~(lock (als (config (rho T j)) p)))
							        	  		     				& (available (config (rho T j )) p)
							        	  		     				& (ready-to (rho T j) p (receive p (consM a p 1b b v)))
												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)

	(!prove Lemma1b-step19 [Lemma1b-step18 synod-ready-to-receive-lemmas synod-quorum-axioms])


	define Lemma1b-step20 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)
							        	   & (
							        	   		  (
							        	   		  	  (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
							        	   		  	 & (available (config (rho T k )) p)
							        	   		  	 & (ready-to (rho T k) p (receive p (consM a p 1b b v)))
													 & (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j z . 
							        	  			   (k N.<= j)

							        	   		  	 & (inMSet (consM a p 1b b v) (mu (config (rho T k))) )
												     & (
												     		   (
												     		   	      (inMSet (consM a p 1b b v) (mu (config (rho T j))))
							        	  		     				& (available (config (rho T j )) p)
							        	  		     				& (ready-to (rho T j) p (receive p (consM a p 1b b v)))
																	 & (j N.<= z) 
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step20 [Lemma1b-step19 Fair-Rcv-Causes-Theorem])	


		
	define Lemma1b-step21 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j z . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (       (k N.<= j) 
																	 & (j N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step21 [Lemma1b-step20 model-step-axioms])			


	define Lemma1b-step22_helper1 := 
			(forall v k y .
        	   		  (    (i N.<= k)
						 & (k N.<= y)
        	   		  )
        	   		  ==> (i N.<= y) 

        	 )  		  		
	(!prove Lemma1b-step22_helper1 [Lemma1b-step20 N.Less=.transitive])			


	define Lemma1b-step22 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j z . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (       (k N.<= j) 
																	 & (j N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22 [Lemma1b-step21 Lemma1b-step22_helper1])


	define Lemma1b-step22_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		          (k N.<= j) 
																	 & (j N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_1 [Lemma1b-step22])


	define Lemma1b-step22_helper2 :=
	(forall p T b i Q .
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		          (k N.<= j) 
																	 & (j N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
																| (exists l . (   (k N.<= l) 
											            	    				& (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))
											            	    			  )
																  )	

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				)  
	     		   ==>
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		          (k N.<= j) 
																	 & (j N.<= z)
																	 & (k N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
						            	    		  		|  (exists l . (k N.<= l)	 
							            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))		

												  			   )

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				)
		)		
	(!prove Lemma1b-step22_helper2 [N.Less=.transitive])


	define Lemma1b-step22_2:= 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		          (k N.<= j) 
																	 & (j N.<= z)
																	 & (k N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
						            	    		  		|  (exists l . (k N.<= l)	 
							            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))		

												  			   )

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


#-- TAKES AGES, give it time (comment out this and assert this step to save time while developing later proofs)
	(!prove Lemma1b-step22_2 [Lemma1b-step22_1 Lemma1b-step22_helper2])


	define Lemma1b-step22_3:= 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		           (k N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )
						            	    		  		 
						            	    		  		|  (exists l . (k N.<= l)	 
							            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T l)) p)))		

												  			   )

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_3 [Lemma1b-step22_2])


	define Lemma1b-step22_4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
											 (i N.<= k)									
							        	    & (
							        	   		  (    (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (
												     		   (exists z .
												     		           (k N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_4 [Lemma1b-step22_3])


	define Lemma1b-step22_5 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k)									
							        	    & (
							        	   		  (exists y .
							        	   		      (k N.<= y) 
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )
							        	  		| (
							        	   		  	   (
												     		   (exists z .
												     		           (k N.<= z)
						            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))							        	   		  	 

												     		   )

				            	    		  	       )

										  		  )								        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_5 [Lemma1b-step22_4])


	define Lemma1b-step22_6 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k .
											 (i N.<= k)									
							        	    & (
							        	   		  (exists y .
							        	   		       (k N.<= y)
							        	   		     & (i N.<= y)  
		            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
							        	   		  )							        	   		

							        	  	 ) 			            	    		     									             	 
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_6 [Lemma1b-step22_5 N.Less=.transitive])


	define Lemma1b-step22_7 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(nonfaulty a) & (acc a) 	
								& (exists v k y .
					        	   		       (i N.<= y)  
            	    				         & (inMSet (consM a p 1b b v) (amu (als (config (rho T y)) p)))
								  )         
					)	
				) 
	)


	(!prove Lemma1b-step22_7 [Lemma1b-step22_6])


	define Lemma1b-step24 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							 (exists v z . 
		     				 	          (i N.<= z)                                                     # for each a, exists k . (rho T z) = then (rho T k) ... implies that
		     				 	       & (inMSet (consM a p 1b b v) (amu (als (config (rho T z)) p)))   # Did not happen at the same time. k is important here 
					        	   		  	 
						     )         
					)	
				) 
	)

	(!prove Lemma1b-step24 [Lemma1b-step22_7])	

	define Lemma1b-step24_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
				                    & (ready-to (rho T i) p (send p (consM p a 1a b nilV)))
			  )
		)
			==> 
				(exists j . (i N.<= j) 
					      & (forall a . (inQ a Q) ==> (exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T j)) p))) )) )

	)


	(!prove Lemma1b-step24_1 [Lemma1b-step24 collect-1b-from-quorum])	


	(!prove Lemma1b [Lemma1b-step24_1 synod-has-promises-def-axiom])


	#-- Lemma1c 
	#-- Connecting 1b to the syntactic sugar for readibility
	#------------------------------------------------------------------------	 
		

	define Lemma1c := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p) 
			& ((all-inQ-NF Q) & (rdy2snd-1a-all-inQ p Q (rho T i) b))
		)
			==> 
  							(exists j .
  									  (i N.<= j)	
						  			& (has-promises (als (config (rho T j)) p) b  Q) 
  							)
	)

	(!prove Lemma1c [Lemma1b CND-def])


	#-- Lemma2a
	#-- In a fair transition path, if eventually a nonfaulty proposer P receives promises for a ballot b that satisfies P1+P2-True,
	#-- from a quorum Q of nonfaulty acceptors, then 2a messages from P will be eventually received by all members of Q for b 
	#------------------------------------------------------------------------

	define Lemma2a := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
							(exists j v .
										 (i N.<= j) 
								       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
							)	       
					)	
				)
	)



	define Lemma2a-step1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==>  
				(forall a . (inQ a Q) ==> (exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) ))
	)		

	(!prove Lemma2a-step1 [synod-has-promises-def-axiom])



	define Lemma2a-step2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				(forall a .
                    ((inQ a Q) 
                    	==> 
                    		(exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) )
                    )
					
				  & (
							(available (config (rho T i )) p)
								==>
									 (exists v2 . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v2))) ) )
					)					



				) 
	)		

	(!prove Lemma2a-step2 [Lemma2a-step1 Snd-Ruls])





	define Lemma2a-step4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
					(forall a .
	                    ((inQ a Q) 
	                    	==> 
	                    		(exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) )
	                    )
						
					  & (
								(available (config (rho T i )) p)
									==>
										 (exists v2 . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v2))) ) )
						)						
					) 
	  		     & (
	  		  		  (available (config (rho T i )) p)

	    	  		| (exists j .
	                             (i N.< j)
	    	  				   & (available (config (rho T j )) p))
	    	  	   )				
	)		

	(!prove Lemma2a-step4 [Lemma2a-step2 proposer-nonfaulty2])


	define Lemma2a-step4_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
					(forall a .
	                    ((inQ a Q) 
	                    	==> 
	                    		(exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) )
	                    )
						
					  & (
								(available (config (rho T i )) p)
									==>
										 (exists v2 . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v2))) ) )
						)
					) 
				  & (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . exists v . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p))
	    	  	   )				
	)		

	(!prove Lemma2a-step4_1 [Lemma2a-step4 N.Less=.Implied-by-<  N.Less=.transitive])


	define Lemma2a-step4_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
					(forall a .
	                    ((inQ a Q) 
	                    	==> 
	                    		(exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) )
	                    )
						
					  & (
								(available (config (rho T i )) p)
									==>
										 (exists v2 . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v2))) ) )
						)
					) 
				  & (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . exists v . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (forall a .
			                   	  	(inQ a Q) 
			                    		 ==> 
			                    			(exists v . (inMSet (consM a p 1b b v) (amu (als (config (rho T i)) p))) )
			                     )
			          )          	    	  		
	    	  	   )				
	)		

	(!prove Lemma2a-step4_2 [Lemma2a-step4_1])


	define Lemma2a-step4_2_2 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . exists v . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (has-promises (als (config (rho T i)) p) b  Q)
			           )          	    	  		
	    	  	   )				
	)		

	(!prove Lemma2a-step4_2_2 [Lemma2a-step4_2 synod-has-promises-def-axiom])


	define persistent-unresponded-local-promises-subaxiom := 
	(forall T i p Q b j .
		(
			(
			      (has-promises (als (config (rho T i)) p) b Q)
			    & (i N.<= j)
			)   
		 	==> (
		 		      (has-promises (als (config (rho T j)) p) b Q)
		 		
					| (exists k v . 
							  (i N.<= k)
						    & (sent2A (als (config (rho T k)) p) b v Q k)	
					  )
				)	
		)
    )

    (!prove persistent-unresponded-local-promises-subaxiom [persistent-unresponded-local-promises])

	define Lemma2a-step4_3 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . exists v . ((inQ a Q) ==> (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (has-promises (als (config (rho T i)) p) b  Q)
						 	& (
						 		      (has-promises (als (config (rho T j)) p) b Q)
						 		
									| (exists k v . 
											  (i N.<= k)
										    & (sent2A (als (config (rho T k)) p) b v Q k)	
									  )
								)
			           


			           )        
	    	  	   )				
	)		

	(!prove Lemma2a-step4_3 [Lemma2a-step4_2_2 persistent-unresponded-local-promises-subaxiom])


	define Lemma2a-step4_4 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v . (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (has-promises (als (config (rho T i)) p) b  Q)
						 	& (
						 			 (	
						 		       (has-promises (als (config (rho T j)) p) b Q)
						 		      & (available (config (rho T j )) p) 
									   & (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v . (ready-to (rho T j) p (send p (consM p a 2a b v))) )
						                 )
						              )    
						 		
									| (exists k v . 
											  (i N.<= k)
										    & (sent2A (als (config (rho T k)) p) b v Q k)	
									  )

								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step4_4 [Lemma2a-step4_3 Snd-Ruls])	




	define Lemma2a-step4_6 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v . (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (has-promises (als (config (rho T i)) p) b  Q)
						 	& (
						 			 (	
						 		       (has-promises (als (config (rho T j)) p) b Q)
						 		      & (available (config (rho T j )) p) 
									   & (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v . (ready-to (rho T j) p (send p (consM p a 2a b v))) )
						                 )
						              )    
						 		
									| (exists k v . 
											  (i N.<= k)
										    & (sent2A (als (config (rho T k)) p) b v Q k)	
									  )

								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step4_6 [Lemma2a-step4_4 Fair-Snd-Causes-Theorem])	


    define helper :=
	(forall p T b i Q k v .   
          (
			   (i N.<= k)
			   & (sent2A (als (config (rho T k)) p) b v Q k)
          	)
          ==>
				      (forall a .
	                    (inQ a Q) 
	                    	==> 
	                    	   (exists u .
	                    	   	        (k N.<= u)
									  #& (= (rho T (S u)) (then (rho T u) (send p (consM p a 2a b v))))
									  & (inMSet (consM p a 2a b v) (mu (config (rho T u))) )	
	                    	   )
	                  )
	 )
	 
	 (!prove helper [symbol-defs])                           


	define Lemma2a-step4_7 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v . (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)  
	    	  				   & (available (config (rho T j )) p)
			                   & (has-promises (als (config (rho T i)) p) b  Q)
						 	& (
						 			 (	
						 		       (has-promises (als (config (rho T j)) p) b Q)
						 		      & (available (config (rho T j )) p) 
									   & (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v . (ready-to (rho T j) p (send p (consM p a 2a b v))) )
						                 )
						              )    
						 		
									| (exists k v . 
											   (i N.<= k)
											   & (sent2A (als (config (rho T k)) p) b v Q k)
											   &  (forall a .
								                    (inQ a Q) 
								                    	==> 
								                    	   (exists u .
								                    	   	        (k N.<= u)
																  #& (= (rho T (S u)) (then (rho T u) (send p (consM p a 2a b v))))
																  & (inMSet (consM p a 2a b v) (mu (config (rho T u))) )	
								                    	   )
								                  )
									  )
								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step4_7 [Lemma2a-step4_6 helper])	



	define Lemma2a-step4_8 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v . (ready-to (rho T i) p (send p (consM p a 2a b v))) ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)    
						 	& (
						 			 (	
									     (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v . (ready-to (rho T j) p (send p (consM p a 2a b v))) )
						                 )
						              )    
						 		
									| (exists k v . 
											   (i N.<= k)
											   & (sent2A (als (config (rho T k)) p) b v Q k)
											   &  (forall a .
								                    (inQ a Q) 
								                    	==> 
								                    	   (exists u .
								                    	   	        (k N.<= u)
								                    	   	      & (i N.<= u)  
																  & (inMSet (consM p a 2a b v) (mu (config (rho T u))) )	
								                    	   )
								                  )
									  )
								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step4_8 [Lemma2a-step4_7 N.Less=.transitive N.Less=.Implied-by-<])


	define Lemma2a-step5 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v j . (i N.<= j) &  (inMSet (consM p a 2a b v) (mu (config (rho T j))) )       ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)    
						 	& (
						 			 (	
									     (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v z .  (j N.<= z) &  (inMSet (consM p a 2a b v) (mu (config (rho T z))) )  )
						                 )
						              )    
						 		
									| (exists k v . 
											   (i N.<= k)
										     & (forall a .
							                    (inQ a Q) 
							                    	==> 
							                    	    (
													        (inMSet (consM p a 2a b v) (mu (config (rho T k))) )
                                                        )
							                   )
									  )
								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step5 [Lemma2a-step4_8 Fair-Snd-Causes-Theorem])


	define Lemma2a-step6 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (

		  		  		  (available (config (rho T i )) p)
		  		  		  & (forall a . (inQ a Q) ==> (exists v j . (i N.<= j) &  (inMSet (consM p a 2a b v) (mu (config (rho T j))) )       ) )
                      )
	    	  		| (exists j .
                                 (i N.<= j)    
						 	& (
						 			 (	
									     (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v z .  (j N.<= z) & (i N.<= z) & (inMSet (consM p a 2a b v) (mu (config (rho T z))) )  )
						                 )
						              )    
						 		
									| (exists k v . 
											   (i N.<= k)
										     & (forall a .
							                    (inQ a Q) 
							                    	==> 
							                    	    (
													        (inMSet (consM p a 2a b v) (mu (config (rho T k))) )
                                                        )
							                   )
									  )
								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step6 [Lemma2a-step5 N.Less=.transitive])



	define Lemma2a-step6_1 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>    
				   (
	  		     	  (
						 (forall a . (inQ a Q) ==> (exists v j . (i N.<= j) &  (inMSet (consM p a 2a b v) (mu (config (rho T j))) )       ) )
                      )
	    	  		| ( (
						 			 (	
									     (forall a .
						                    (inQ a Q) 
						                    	==> 
						                    		(exists v z . (i N.<= z) & (inMSet (consM p a 2a b v) (mu (config (rho T z))) )  )
						                 )
						              )    
						 		
									| (
										      (forall a .
							                    (inQ a Q) 
							                    	==> 
							                    	    (
													      exists v k . (i N.<= k) &  (inMSet (consM p a 2a b v) (mu (config (rho T k))) )
                                                        )
							                   )
									  )
								)
			           


			           )        
	    	  	   )				
	)	

	(!prove Lemma2a-step6_1 [Lemma2a-step6])

	define Lemma2a-step7 :=
	 (forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==>    
			     (forall a .
                    (inQ a Q) 
                    	==> 
                    		(exists v k . 
		                             (i N.<= k)
                    			   & (inMSet (consM p a 2a b v) (mu (config (rho T k))) )	
                    	    )
                 )						   

	)

	(!prove Lemma2a-step7 [Lemma2a-step6_1])

	define Lemma2a-step8 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==>    
			     (forall a .
                    (inQ a Q) 
                    	==> 
                    		(exists v j . 
		                             (i N.<= j)
                    			   & (inMSet (consM p a 2a b v) (mu (config (rho T j))) )

			        	  		  & (
			        	  		  		  (available (config (rho T j )) a)

			    		    	  		| (exists k .
		                                             (j N.< k)
			    		    	  				   & (available (config (rho T k )) a))
			    		    	  	  )	
                    	    )
                 )						   

	)	

	(!prove Lemma2a-step8 [Lemma2a-step7 acceptor-nonfaulty1 synod-quorum-axioms])



	define Lemma2a-step10 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  & (
							        	  		  
							        	  		  ( 
							        	  		  	   #(~(lock (als (config (rho T j)) a)))
							        	  		  	  (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  		  	 & (available (config (rho T j )) a)

							        	  		  )
							        	  		  	 
							        	  		| (exists k . (j N.<= k)
										  				  # & ~(lock (als (config (rho T k)) a))
										  		           & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
										  		           & (available (config (rho T k )) a)
										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step10 [Lemma2a-step8 N.Less=.Implied-by-<])	


	

	define Lemma2a-step11 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==>  
				(forall a . 
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  & (
							        	  		  
							        	  		  ( 
							        	  		  	   (available (config (rho T j )) a)
							        	  		  	 & (inMSet (consM p a 2a b v) (mu (config (rho T j))))

							        	  		  )
							        	  		  	 
							        	  		| (exists k . (j N.<= k)
										  				   & (available (config (rho T k )) a)
										  		           & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
  	   													   & (
							            	    		  		   (inMSet (consM p a 2a b v) (mu (config (rho T k))))

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 2a b v) (amu (als (config (rho T l)) a)))
											            	    			  )

																  )							            	    		  		

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step11 [Lemma2a-step10 synod-msg-persistance-axioms])





	define Lemma2a-step13 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  & (
							        	  		  
							        	  		  ( 
							        	  		  	   (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  		  	 & (nonfaulty a)
							        	  		  	 & (available (config (rho T j )) a)
							        	  		  	 & (ready-to (rho T j) a (receive a (consM p a 2a b v)))	
							        	  		  )
							        	  		  	 
							        	  		| (exists k . (j N.<= k)
										  		           & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
  	   													   & (
  	   													   		  (
								            	    		  		   (inMSet (consM p a 2a b v) (mu (config (rho T k))))
								            	    		  		   & (nonfaulty a)
								            	    		  		   & (available (config (rho T k )) a)
								            	    		  		   & (ready-to (rho T k) a (receive a (consM p a 2a b v)))

  	   													   		  )	

																| (exists l . (   (j N.<= l) 
											            	    				& (inMSet (consM p a 2a b v) (amu (als (config (rho T l)) a)))
											            	    			  )

																  )	

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step13 [Lemma2a-step11 synod-ready-to-receive-lemmas synod-quorum-axioms])	



	define Lemma2a-step14 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  & (
							        	  		  
							        	  		  ( 

										               (exists y . (j N.<= y) 
								            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T y)) a)))) 							        	  		  	 	
							        	  		  )
							        	  		  	 
							        	  		| (exists k . (j N.<= k)
										  		           & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
  	   													   & (
  	   													   		  (

															               (exists z . (k N.<= z) 
													            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))) 							        	  		  	 	

  	   													   		  )	

							            	    		  		| (exists l . (j N.<= l) 
								            	    				        & (= (rho T l) (then (rho T j) (receive a (consM p a 2a b v))))   
													  				)

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step14 [Lemma2a-step13 Fair-Rcv-Causes-Theorem])


	define Lemma2a-step15 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (inMSet (consM p a 2a b v) (mu (config (rho T j))))
							        	  & (
							        	  		  
							        	  		  ( 

										               (exists y . (j N.<= y)
										                         & (i N.<= j)
										                         & (i N.<= y) 
								            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T y)) a)))) 							        	  		  	 	
							        	  		  )
							        	  		  	 
							        	  		| (exists k . (j N.<= k)
							        	  			       & (i N.<= j)
							        	  			       & (i N.<= k)
  	   													   & (
  	   													   		  (

															               (exists z . (k N.<= z)
															                         & (j N.<= k)
															                         & (j N.<= z)
															                         & (i N.<= k) 
													            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))) 							        	  		  	 	

  	   													   		  )	

							            	    		  		| (exists l . (j N.<= l)
							            	    		  					& (i N.<= j)
							            	    		  					& (i N.<= l)	 
								            	    				        & (= (rho T l) (then (rho T j) (receive a (consM p a 2a b v))))   
													  				)

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step15 [Lemma2a-step14 N.Less=.transitive])



	define Lemma2a-step16 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (
							        	  		  
							        	  		  ( 

										               (exists y . (i N.<= y) 
								            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T y)) a)))) 							        	  		  	 	
							        	  		  )
							        	  		  	 
							        	  		| (exists k . 
  	   													     (
  	   													   		  (

															               (exists z . (i N.<= z) 
													            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))) 							        	  		  	 	

  	   													   		  )	

							            	    		  		| (exists l . (i N.<= l)	 
								            	    				        & (= (rho T l) (then (rho T j) (receive a (consM p a 2a b v))))   
													  				)

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step16 [Lemma2a-step15 N.Less=.transitive])


	define Lemma2a-step17 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>  
				(forall a .
					((inQ a Q) 
						==> 
								(exists v . 
									       (
							        	  		  
							        	  		  ( 

										               (exists y . (i N.<= y) 
								            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T y)) a)))) 							        	  		  	 	
							        	  		  )
							        	  		  	 
							        	  		| ( 
  	   													     (
  	   													   		  (

															               (exists z . (i N.<= z) 
													            	       		     & (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))) 							        	  		  	 	

  	   													   		  )	

							            	    		  		| (exists l . (i N.<= l)	 
								            	    				        & (inMSet (consM p a 2a b v) (amu (als (config (rho T l)) a)))    
													  				)

						            	    		  	      )


										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step17 [Lemma2a-step16 model-step-axioms])

	define Lemma2a-step18 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==>
				(forall a .
					((inQ a Q) 
						==> 
								(exists j v . (i N.<= j) 
							        	  & (
							        	  		  
							        	  		  ( 
						            	    		   (exists z .
		            	    		  	      			  (i N.<= z)   
				            	    					& (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))									            	    		    
						            	    		   )							        	  		  	 	
							        	  		  )
							        	  		  	 
							        	  		| (exists y . 
								            	    		  		     (
							            	    		  	      			  (i N.<= y)   
									            	    					& (inMSet (consM p a 2a b v) (amu (als (config (rho T y)) a)))									            	    		    
											            	    		 )								            	    		  		   
						            	    		  	      
										  		  )	   
							        	  	) 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step18 [Lemma2a-step17 model-step-axioms])


	define Lemma2a-step19 := 
	(forall p T b i Q .
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==>
				(forall a .
					((inQ a Q) 
						==> 
								(exists z v .  
		            	    		  	      			  (i N.<= z)   
				            	    					& (inMSet (consM p a 2a b v) (amu (als (config (rho T z)) a)))									            	    		    
							        	  		  	 
							    )	       
					)	
				) 
	)


	(!prove Lemma2a-step19 [Lemma2a-step18])

	(!prove Lemma2a [Lemma2a-step19])




	#-- Lemma2b
	#-- In a fair transition path, if eventually a nonfaulty proposer P receives promises for a ballot b that satisfies P1+P2-True,
	#-- from a quorum Q of nonfaulty acceptors, then P will eventually receive 2b messages from all members of Q for b 
	#------------------------------------------------------------------------


	define Lemma2b := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(exists j .
						  (i N.<= j)	
		  			    & (has-votes (als (config (rho T j)) p) b Q) 
				)			

	)




	define Lemma2b-step1 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
								)	       
						)	
				  )		
	)			


	(!prove Lemma2b-step1 [Lemma2a synod-quorum-axioms])


	define Lemma2b-step2 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
									       & ((beta (als (config (rho T j)) a)) =< b) 
								)	       
						)	
				  )		
	)		


	(!prove Lemma2b-step2 [Lemma2b-step1 P1+P2-True-2a-beta])	




	define Lemma2b-step4 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
									       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   & (
					        	  		  		  (available (config (rho T j )) a)

					    		    	  		| (exists k .
				                                             (j N.< k)
					    		    	  				   & (available (config (rho T k )) a))
					    		    	  	 )									       

								)	       
						)	
				  )		
	)

	(!prove Lemma2b-step4 [Lemma2b-step2 acceptor-nonfaulty2])	




	define Lemma2b-step4_1 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
									       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   & (
					        	  		   		  (
							        	  		  		 (available (config (rho T j )) a)					        	  		   		  	
												       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
												       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   		  )	

					    		    	  		| (exists k .
				                                             (j N.<= k)
					    		    	  				   & (available (config (rho T k )) a)
  				   									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a)))
  				   								   )	       

					    		    	  	 )									       

								)	       
						)	
				  )
		)		  		

	(!prove Lemma2b-step4_1 [Lemma2b-step4 N.Less=.Implied-by-<])

	define Lemma2b-step5 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
									       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   & (
					        	  		   		  (
							        	  		  		 (available (config (rho T j )) a)					        	  		   		  	
												       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
												       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   		  )	
					    		    	  		| (exists k .
				                                             (j N.<= k)
					    		    	  				   & (available (config (rho T k )) a)
					    		    	  				   & (	
					    		    	  				   	      (
					    		    	  				   	         (inMSet (consM p a 2a b v) (amu (als (config (rho T k)) a)))
					    		    	  				   	         & (available (config (rho T k )) a) 
                                                                   )
																| (exists t . 
																		(j N.<= t)
																		& (inMSet (consM a p 2b b v) (mu (config (rho T t))) )

																  )

					    		    	  				   	 )
					    		    	  		  )	   

					    		    	  	 )									       

								)	       
						)	
				  )		
	)



	(!prove Lemma2b-step5 [Lemma2b-step4_1 persistent-unresponded-local-2a-msgs-causes P1+P2-True-2a-beta])



	define Lemma2b-step6 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
										   & (acc a)
										   & (nonfaulty a) 
									       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
									       & ((beta (als (config (rho T j)) a)) =< b)
					        	  		   & (
					        	  		   		  (
							        	  		  		 (available (config (rho T j )) a)					        	  		   		  	
												       & (inMSet (consM p a 2a b v) (amu (als (config (rho T j)) a))) 
												       & ((beta (als (config (rho T j)) a)) =< b)
												       & (ready-to (rho T j) a (send a (consM a p 2b b v) ) )
					        	  		   		  )	
					    		    	  		| (exists k .
				                                             (j N.<= k)
					    		    	  				   & (available (config (rho T k )) a)
					    		    	  				   & (    
					    		    	  				   	      (
					    		    	  				   	      		(inMSet (consM p a 2a b v) (amu (als (config (rho T k)) a)))
					    		    	  				   	      		& (available (config (rho T k )) a) 
					    		    	  				   	      		 & ((beta (als (config (rho T k)) a)) =< b)
					    		    	  		   		   	      		& (ready-to (rho T k) a (send a (consM a p 2b b v) ) )
                                                                  )
																| (exists t . 
																		(j N.<= t)
																		& (inMSet (consM a p 2b b v) (mu (config (rho T t))) )

																  )

					    		    	  				   	 )
					    		    	  		  )	 

					    		    	  	 )									       

								)	       
						)	
				  )		
	)

	(!prove Lemma2b-step6 [Lemma2b-step5 Snd-Ruls P1+P2-True-2a-beta])	


	define Lemma2b-step6_1 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
					        	  		   & (
					        	  		   		  (
										                 (exists y . (j N.<= y)
										                            & (i N.<= j) 
								            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T y))) )
														 )  													       
					        	  		   		  )	
					    		    	  		| (exists k .
				                                             (j N.<= k)
					    		    	  				   & (    
					    		    	  				   	      (
															                 (exists z . (k N.<= z)
															                            & (j N.<= k) 
													            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T z))) )
																			 )  													       

                                                                  )
																| (exists t . 
																		(j N.<= t) 
																		& (i N.<= j)
																		& (inMSet (consM a p 2b b v) (mu (config (rho T t))) )

																  )

					    		    	  				   	 )
					    		    	  		  )	 

					    		    	  	 )									       

								)	       
						)	
				  )		
	)

	(!prove Lemma2b-step6_1 [Lemma2b-step6 Fair-Snd-Causes-Theorem model-step-axioms N.Less=.Implied-by-<])	


	define Lemma2b-step6_2 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
											 (i N.<= j)
					        	  		   & (
					        	  		   		  (
										                 (exists y . (i N.<= y) 
								            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T y))) )
														 )  													       
					        	  		   		  )	
					    		    	  		| (exists k .
				                                              (    
					    		    	  				   	      (
															                 (exists z . (j N.<= z)
															                 			& (i N.<= j) 
													            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T z))) )
																			 )  													       

                                                                  )
																| (exists t . 
																		(i N.<= t)
																		& (inMSet (consM a p 2b b v) (mu (config (rho T t))) )
																  )

					    		    	  				   	 )
					    		    	  		  )	 

					    		    	  	 )									       

								)	       
						)	
				  )		
	)

	(!prove Lemma2b-step6_2 [Lemma2b-step6_1 N.Less=.transitive])



	define Lemma2b-step6_3 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
								(exists j v .
								            (
					        	  		   		  (
										                 (exists y . (i N.<= y) 
								            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T y))) )
														 )  													       
					        	  		   		  )	
					    		    	  		| (exists k .
				                                              (    
					    		    	  				   	      (
															                 (exists z . (i N.<= z) 
													            	    				& (inMSet (consM a p 2b b v) (mu (config (rho T z))) )
																			 )  													       

                                                                  )
																| (exists t . 
																		(i N.<= t)
																		& (inMSet (consM a p 2b b v) (mu (config (rho T t))) )
																  )

					    		    	  				   	 )
					    		    	  		  )	 

					    		    	  	 )									       

								)	       
						)	
				  )		
	)

	(!prove Lemma2b-step6_3 [Lemma2b-step6_2 N.Less=.transitive])

	define Lemma2b-step7 := 		
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
							(exists k v .
				 	       			     (i N.<= k) 
		            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) ) 									       
								       	 
							)	       
						)	
				  )		
	)

	(!prove Lemma2b-step7 [Lemma2b-step6_3])		




	define Lemma2b-step8 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
							(exists k v .
				 	       			     (i N.<= k) 
		            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
				        	  		   & (
				        	  		  		  (available (config (rho T k )) p)

				    		    	  		| (exists j .
			                                             (k N.< j)
				    		    	  				   & (available (config (rho T j )) p))
				    		    	  	  )			            	    		   

								       	 
							)	       
						)	
				  )		
	)		


	(!prove Lemma2b-step8 [Lemma2b-step7 proposer-nonfaulty1])	


	define Lemma2b-step9 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
							(exists k v .
				 	       			     (i N.<= k) 
				        	  		   & (
				        	  		   		(
				        	  		  		     (available (config (rho T k )) p)
				            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
				        	  		   		)

				    		    	  		| (exists j .
			                                             (k N.<= j)
				    		    	  				   & (available (config (rho T j )) p)
						            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
				    		    	  		  )
				    		    	  	  )			            	    		   

								       	 
							)	       
						)	
				  )		
	)		


	(!prove Lemma2b-step9 [Lemma2b-step8 N.Less=.Implied-by-<])



	define Lemma2b-step12 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
		    	 (forall a .
						((inQ a Q) 
							==> 
							(exists k v .
				 	       			     (i N.<= k) 
				        	  		   & (
				        	  		   		(
				        	  		  		     (available (config (rho T k )) p)
				            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
				        	  		   		)

				    		    	  		| (exists j .
			                                             (k N.<= j)
				    		    	  				   & (available (config (rho T j )) p)
						            	    		   & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
												       & (
						            	    		  		   (inMSet (consM a p 2b b v) (mu (config (rho T j))))

															| (exists l .    
															   	       (k N.<= l) 
										            	    		 & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))		  
										            	      )							            	    		  		

				            	    		  	         )						            	    		   
				    		    	  		  )
				    		    	  	  )			            	    		          	 
							)	       
						)	
				  )		
	)

	(!prove Lemma2b-step12 [Lemma2b-step9 2b-model-msg-persists-until-read-axiom-lemma])				



	define Lemma2b-step14 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(exists k v .
				 	       			     (i N.<= k) 									       
						        	   & (
							        	   	      (
							        	   	      	      #(~(lock (als (config (rho T k)) p)))
							        	   	      		  (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
							        	   	      		& (available (config (rho T k )) p)
							        	   	      )
						        	  		  
							        	  		| (exists j . 
							        	  			   (k N.<= j)
							        	   		  	 & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
												     & (
												     		   (
												     		   	      (inMSet (consM a p 2b b v) (mu (config (rho T j))))
							        	  		     				#& (~(lock (als (config (rho T j)) p)))
							        	  		     				& (available (config (rho T j )) p)
												     		   )
						            	    		  		 
															| (exists l .    
															   	       (k N.<= l) 
										            	    		 & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))		  
										            	      )							            	    		  		


				            	    		  	       )

										  		  )								        	  	 
							        	 )								       	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step14 [Lemma2b-step12 proposer-nonfaulty1])	


	define Lemma2b-step15 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(exists k v .
				 	       			     (i N.<= k) 									       
						        	   & (
							        	   	      (
							        	   	      	     # (~(lock (als (config (rho T k)) p)))
							        	   	      		  (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
							        	   	      		& (available (config (rho T k )) p)
							        	   	      		& (ready-to (rho T k) p (receive p (consM a p 2b b v)))
							        	   	      )
						        	  		  
							        	  		| (exists j . 
							        	  			   (k N.<= j)

							        	   		  	 & (inMSet (consM a p 2b b v) (mu (config (rho T k))) )
												     & (
												     		   (
												     		   	      (inMSet (consM a p 2b b v) (mu (config (rho T j))))
							        	  		     			#	& (~(lock (als (config (rho T j)) p)))
							        	  		     				& (available (config (rho T j )) p)
							        	  		     				& (ready-to (rho T j) p (receive p (consM a p 2b b v)))
												     		   )
						            	    		  		 
															| (exists l .    
															   	       (k N.<= l) 
										            	    		 & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))		  
										            	      )							            	    		  		


				            	    		  	       )

										  		  )								        	  	 
							        	 )								       	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step15 [Lemma2b-step14 synod-ready-to-receive-lemmas synod-quorum-axioms])	


	define Lemma2b-step16 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(exists k v .
				 	       			     (i N.<= k) 									       
						        	   & (
							        	   	      (
										            	 (exists y . (k N.<= y)
										            	 			& (i N.<= k) 
								            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T y)) p))))  							        	   	      		
							        	   	      )
						        	  		  
							        	  		| (exists j . 
							        	  			   (k N.<= j)
												     & (
												     		   (

													            	 (exists z . (j N.<= z)
													            	 			& (k N.<= j)
													            	 			& (i N.<= k) 
											            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T z)) p))))  							        	   	      		

												     		   )
						            	    		  		 
						            	    		  		|  (exists l . (k N.<= l)
						            	    		  					 & (i N.<= k)	 
							            	    				         & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))   
												  			   )

				            	    		  	       )

										  		  )								        	  	 
							        	 )								       	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step16 [Lemma2b-step15 Fair-Rcv-Causes-Theorem model-step-axioms])	

	
	define Lemma2b-step17 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(exists k v .
				 	       			     (i N.<= k) 									       
						        	   & (
							        	   	      (
										            	 (exists y . (k N.<= y)
										            	 			& (i N.<= k)
										            	 			& (i N.<= y) 
								            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T y)) p))))  							        	   	      		
							        	   	      )
						        	  		  
							        	  		| (exists j . 
							        	  			   (k N.<= j)
												     & (
												     		   (

													            	 (exists z . (j N.<= z)
													            	 			& (k N.<= j)
													            	 			& (i N.<= k)
													            	 			& (k N.<= z)
											            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T z)) p))))  							        	   	      		

												     		   )
						            	    		  		 
						            	    		  		|  (exists l . (k N.<= l)
						            	    		  					 & (i N.<= k)
						            	    		  					 #& (i N.<= l)	 
							            	    				         & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))   
												  			   )

				            	    		  	       )

										  		  )								        	  	 
							        	 )								       	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step17 [Lemma2b-step16 N.Less=.transitive])	


	define Lemma2b-step18 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q)
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(exists k v . (
							        	   	      (
										            	 (exists y . (i N.<= y) 
								            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T y)) p))))  							        	   	      		
							        	   	      )
						        	  		  
							        	  		| (exists j . 
							        	  			   (k N.<= j)
												     & (
												     		   (

													            	 (exists z .  (i N.<= z)
											            	    				& (inMSet (consM a p 2b b v) (amu (als (config (rho T z)) p))))  							        	   	      		

												     		   )
						            	    		  		 
						            	    		  		|  (exists l .  (i N.<= l)	 
							            	    				         & (inMSet (consM a p 2b b v) (amu (als (config (rho T l)) p)))   
												  			   )

				            	    		  	       )

										  		  )								        	  	 
							        	 )								       	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step18 [Lemma2b-step17 N.Less=.transitive])	


	define Lemma2b-step19 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> 
				(forall a .
					((inQ a Q) 
						==> 
							(
  		     				  (exists z v .  (i N.<= z)
  		     				 	        &  (inMSet (consM a p 2b b v) (amu (als (config (rho T z)) p))) 

  		     				  )							        	   	      		
						        	  		  							        	  	 
							)	       
					)	
				)
	)		


	(!prove Lemma2b-step19 [Lemma2b-step18])



	define Lemma2b-step20 := 
	(forall p T b i Q . 
		( 
			  (prp p) 
			& (P1+P2-True b)
			& (nonfaulty p)
			& (forall a . (inQ a Q) 
				                ==> 
                                      (nonfaulty a) 
			  )			 
			& (has-promises (als (config (rho T i)) p) b Q) 
		)
			==> (
					(forall a .
						((inQ a Q) 
							==> 
								(
	  		     				  (exists z v .  (i N.<= z)
	  		     				 	          &  (inMSet (consM a p 2b b v) (amu (als (config (rho T z)) p))) 

	  		     				  )							        	   	      		
							        	  		  							        	  	 
								)	       
						)	
					)
				& (exists k . (i N.<= k) 
					      & (forall a . (inQ a Q) ==> (exists v . (inMSet (consM a p 2b b v) (amu (als (config (rho T k)) p))) ))
				  )


				)

	)		


	(!prove Lemma2b-step20 [Lemma2b-step19 collect-2b-from-quorum])

	(!prove Lemma2b [Lemma2b-step20 synod-has-votes-def-axiom])



#----------------------------------------------------------------------------
#-- PROVING THE MAIN PROGRESS THEOREM
#----------------------------------------------------------------------------

	define Lemma1 := 
	(forall p T b i Q .
		( 
			  (prp p)
			& (nonfaulty p)   
			& (P1+P2-True b)
			& ((all-inQ-NF Q) & (rdy2snd-1a-all-inQ p Q (rho T i) b))
		)	
			==> 
				(exists j .
						  (i N.<= j)	
			  			& (has-promises (als (config (rho T j)) p) b Q) 
				)
	)

	(!prove Lemma1 [Lemma1c])



	define Lemma2 := 
	(forall p T b i Q . 
		( 
			  (prp p)
			& (nonfaulty p)   
			& (P1+P2-True b)			 
			& (has-promises (als (config (rho T i)) p) b Q)
			& (all-inQ-NF Q) 
		)
			==> 
				(exists j .
						  (i N.<= j)	
		  			    & (has-votes (als (config (rho T j)) p) b Q) 
				)			

	)

	(!prove Lemma2 [Lemma2b all-inQ-NF-def])



#-- DEFINING THE MAIN PROGRESS THEOREM
#----------------------------------------------------------------------------
	#-- Our main progress theorem states that for all transaction paths, there is an indexed position such that
	#-- a proposer has learnt of a ballot's success at that position 
	define Progress-Theorem :=
	(CND
		==>
			(forall T . 
				(exists p i b .
					 (learn p (config (rho T i)) b)	
				)
			)
	)

	define Progress-Theorem-step1 :=
	( CND
		==>
		(forall T .
			(exists i p b Q . 
				( 
					  (prp p)
					& (nonfaulty p)   
					& (P1+P2-True b) 
					& ((all-inQ-NF Q) & (rdy2snd-1a-all-inQ p Q (rho T i) b))
				)
					 
			& 
				(exists j .
						  (i N.<= j)	
		  			& (has-promises (als (config (rho T j)) p) b Q) 
				)
			)		 
		)

	)	 


	(!prove Progress-Theorem-step1 [Lemma1])	



	define Progress-Theorem-step2 := 
	( CND
		==>
		(forall T .
			(exists i p b Q . 
				( 
					  (prp p) 
					& (nonfaulty p)  
					& (P1+P2-True b) 
					& (has-promises (als (config (rho T i)) p) b Q)
					& (all-inQ-NF Q)						 
				)					 

			&	(exists j .
						  (i N.<= j)	
		  			& (has-votes (als (config (rho T j)) p) b Q) 
				)
				
			)		 
		)
	)	


	(!prove Progress-Theorem-step2 [Progress-Theorem-step1 Lemma2])


	(!prove Progress-Theorem [Progress-Theorem-step1 Progress-Theorem-step2 synod-learn-def-axiom])



}#close module	
